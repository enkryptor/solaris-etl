# CLI Tool

## Быстрый старт

1. Создать локальную копию: `git clone https://github.com/enkryptor/solaris-etl.git`
2. Установить зависимости: `npm install`
3. Запустить сервис СУБД (проверялось на postgres)
4. Настроить доступ к СУБД в файле `.env`
5. Запустить `npm start`


## Требования

Библиотека и консольная утилита для автоматической загрузки данных о состояниях объектов из разных форматов. Нужно реализовать загрузку из CSV и предусмотреть расширение.

Данные должны загружаться в СУБД в таком виде, чтобы впоследствии можно было легко их найти по датам. Конечная цель (в задачу не входит, но важно для понимания контекста) — формирование дельты вида "что появилось, что пропало, что изменилось" и визуализация. На входе запроса в этом случае будет диапазон отметок времени, на выходе — коллекция состояний.

### Уточнения по данным:

- Объект однозначно идентифицируется кодом (текстовая строка), коды уникальны.
- Каждый объект имеет меняющееся состояние, слепок которого приходит в пакете входящих данных.
- Состояние объекта включает в себя геометрию и данные физико-химического зондирования (ФХЗ).
- Состояние объекта может не измениться в новом пакете входящих данных
- Во входящих данных состояние объекта однозначно идентифицируется отметкой времени. Не может быть две версии одного и того же объекта на одну и ту же дату-время. Может быть ноль — это значит, что объект в этот момент не наблюдался (исчез).

### Уточнения по НФТ

- Количество данных: сотни тысяч записей в одном пакете (хранит состояния всех существующих на момент замера объектов).
- Новые данные приходят раз в час.
- BLOB с данными ФХЗ весит десятки мегабайт.
- Оптимизировать скорость загрузки и расход памяти:
    - загружать один пакет не дольше 10 минут
    - не дублировать данные измерений, если они не изменились


## Схема СУБД

**Таблица объектов**
- id (PK)
- код: строка (индексируемое поле)

**Таблица замеров**
- id (PK)
- дата-время (timestamp, индексируемое)

**Таблица состояний объектов**
- id (PK)
- замер: FK в таблице замеров, многие к одному
- объект: FK в таблице объектов, многие к одному
- данные геометрии: FK в таблице геометрий объектов, многие к одному
- данные физико-химического зондирования: FK в таблице хэшей ФХЗ, многие к одному

**Таблица геометрий объектов**
- id (PK)
- широта: double
- долгота: double
- радиус: double

**Таблица хэшей данных ФХЗ**
- id (PK)
- хэш xxHash
- данные: FK в таблице данных ФХЗ, один к одному

**Таблица данных ФХЗ**
- id (PK)
- данные: bytea

### Варианты оптимизации БД

- Добавить constraint: комбинация "объект + замер" в таблице состояний уникальна.
- Установить фиксированную длину кода объекта.


## API библиотеки

TBD


## Консольная утилита

```sh
solaris-etl import ./path/to/file.csv
```


## Аргументация и решения

Отдельная таблица замеров нужна, чтобы различать отсутствие данных и исчезновение объекта. Если замер существует, но состояния объекта в нём не нашлось — это явно говорит о том, что на момент замера объект исчез.

Работать с таблицей данных ФХЗ как со справочником, не дублировать для разных объектов — не оптимально, т.к. замедлит запись, при том что шансы совпадения ФХЗ для разных объектов околонулевые. Не делаем выборку по таблице блобов, только получаем по id.

Мы хотим экономить место и не писать лишнего. Было бы логично не создавать новую версию, если ничего не поменялось. Однако так делать нельзя т.к. версия содержит информацию о существовании объекта в указанный момент времени. Поэтому для каждого замера всегда создаём новую версию состояния, но ссылаемся на предыдущие значения, если они не изменились.

Отдельная таблица хэшей нужна для оптимизации чтения, т.к. postgres всегда читает данные построчно, даже если не все поля запрошены в выборке.
